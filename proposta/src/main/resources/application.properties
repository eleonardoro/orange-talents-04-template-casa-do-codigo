#spring
#spring.main.banner-mode=off
#logging.level.org.springframework=ERROR
#logging.level.org.springframework.security=TRACE
server.port=${SERVER_PORT:9596}

#datasource
spring.datasource.initialization-mode=always
spring.datasource.platform=postgres
spring.datasource.url=${POSTGRES_URL:jdbc:postgresql://localhost:5432/proposta}
spring.datasource.username=${POSTGRES_USERNAME:keycloak}
spring.datasource.password=${POSTGRES_PASSWORD:password}

# jpa
spring.jpa.hibernate.ddl-auto=update
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.show_sql=true
spring.jpa.properties.hibernate.format_sql=true

#urls
url.analise.proposta=${ANALISE_PROPOSTA_URL:http://localhost:9999}
path.analise.proposta=${ANALISE_PROPOSTA_PATH:/api/solicitacao}
path.analise.proposta.healtchek=${ANALISE_PROPOSTA_PATH_HEALTHCHECK:/actuator/health}
url.criacao.do.cartao=${CRIACAO_DO_CARTAO_URL:http://localhost:8888}
path.criacao.do.cartao=${CRIACAO_DO_CARTAO_PATH:/api/cartoes}
url.bloqueio.cartao=${BLOQUEIO_CARTAO_URL:http://localhost:8888}
path.bloqueio.cartao=${BLOQUEIO_CARTAO_PATH:/api/cartoes/{id}/bloqueios}
url.aviso.de.viagem.cartao=${AVISO_DE_VIAGEM_CARTAO_URL:http://localhost:8888}
path.aviso.de.viagem.cartao=${AVISO_DE_VIAGEM_CARTAO_PATH:/api/cartoes/{id}/avisos}
url.associa.carteira.digital.cartao=${ASSOCIA_CARTEIRA_DIGITAL_CARTAO_URL:http://localhost:8888}
path.associa.carteira.digital.cartao=${ASSOCIA_CARTEIRA_DIGITAL_CARTAO_PATH:/api/cartoes/{id}/carteiras}

#security
##onde o Spring Security pode encontrar nosso authorization server
spring.security.oauth2.resourceserver.jwt.issuer-uri=${KEYCLOAK_ISSUER_URI:http://localhost:18080/auth/realms/cartaoproposta}
##aonde o Spring Security pode encontrar as chaves para conseguir validar a assinatura do token
spring.security.oauth2.resourceserver.jwt.jwk-set-uri=${KEYCLOAK_JWKS_URI:http://localhost:18080/auth/realms/cartaoproposta/protocol/openid-connect/certs}

# timers
cartao.solicitacao.delay=${DELAY_SOLICITACAO_CRIACAO_CARTAO:30000}

# actuator
management.endpoint.health.show-details=always
management.endpoint.health.group.liveness.include=*
management.endpoint.health.group.readiness.include=*
management.endpoint.health.group.liveness.show-details=always
management.endpoint.health.group.readiness.show-details=always
management.endpoint.health.probes.enabled=true
management.endpoints.web.exposure.include=*
management.endpoint.metrics.enabled=true
management.endpoint.prometheus.enabled=true
management.metrics.export.prometheus.enabled=true

info.app.name=@project.name@
info.app.description=@project.description@
info.app.version=@project.version@
info.app.encoding=@project.build.sourceEncoding@
info.app.java.version=@java.version@
info.app.java.source=@java.version@
info.app.java.target=@java.version@

# Jaeger
##Habilita ou não
opentracing.jaeger.enabled=${JAEGER_ENABLED:true}
## Nome do serviço
opentracing.jaeger.service-name=@project.name@
## Endereço para enviar os metadados (trace, span, etc)
opentracing.jaeger.http-sender.url=${JAEGER_ENDPOINT:http://localhost:14268/api/traces}
## Tipo de Amostragem Probabilístico -> (1 = 100%) / (0.5 = 50%) / (0.3 = 30%) 
opentracing.jaeger.probabilistic-sampler.sampling-rate=${JAEGER_SAMPLER_PROBABILISTIC:1}
## Tipo de Rate Limit -> 3, 5, 10 operações por segundo
opentracing.jaeger.rate-limiting-sampler.max-traces-per-second=${JAEGER_SAMPLER_RATE_LIMIT:10}
## Tipo de Amostragem Constante -> True para enviar 100%
opentracing.jaeger.const-sampler.decision=${JAEGER_SAMPLER_CONSTANT:true}
## Se travar no log "Triggering deferred initialization of Spring Data repositories…"
## desabilitar a configuração de OpenTracing para JDBC
#opentracing.spring.cloud.jdbc.enabled=false

# Encrypt
myapplication.encrypt.salt=${APPLICATION_ENCRYPT_SALT:5c0744940b5c369b}
myapplication.encrypt.password=${APPLICATION_ENCRYPT_PASSWORD:5c0744940b5c369b}